# Match Three Improvement Plan

## Vision
- Evolve the game into a polished “neon arcade” match-three with deeper systems, expressive feedback, and replayable goals.
- Maintain a static, GitHub Pages–friendly build that anyone can open directly from `docs/` without a dev server.

## Constraints & Principles
- No bundlers that require a runtime dev server (skip Vite/Parcel). Prefer deterministic CLI builds (`tsc`, `esbuild`).
- Keep `docs/` as the deploy root; all compiled assets must live there for GitHub Pages.
- Preserve compatibility with direct file opens (`docs/index.html`) and simple static hosts (`python3 -m http.server`).

## Phase 1 – Core Systems Refresh
- Refactor game state into modules (`GameState`, `GridController`, `MatchFinder`, `Animation`, `Items`, `UIBindings`).
- Replace globals with a structured state object plus a lightweight event bus.
- Introduce deterministic seeding for reproducible boards; add restart-with-seed controls.
- Establish testing: unit tests for match detection, gravity, inventory rewards.
- Tooling setup:
  - Move source to `src/`, assets to `public/`.
  - Compile with TypeScript (`tsc`) or `esbuild` CLI into `docs/game.bundle.js`.
  - Add ESLint + Prettier configs; provide `npm run build`, `npm run watch`, `npm run lint`, `npm test`.

## Phase 2 – Gameplay Depth
- Rebalance scoring (combo tiers, move efficiency bonuses, streak rewards) and surface in UI.
- Add special tiles generated by larger matches (line clears, bombs, color changers) integrated with the item system.
- Expand inventory with craftable boosters and per-use cooldowns.
- Create themed gem sets, backdrop animations, and destruction particle effects.

## Phase 3 – Progression & UX
- Implement level goals (target score, clear blockers, rescue items) with move limits and board obstacles (locked tiles, ice, portals).
- Build meta-progression: player profile, XP, achievements, daily quests; persist data in localStorage with schema versioning.
- Redesign UI with responsive layout, in-game tutorial, accessibility toggles (colorblind palettes, reduced motion, keyboard controls).
- Integrate `p5.sound` for layered music and SFX with audio settings menu.

## Phase 4 – Live Ops & Polish
- Add daily/weekly seeded challenge boards and shareable codes for friendly competitions.
- Provide optional online leaderboard via serverless backend (e.g., Supabase) while retaining offline high scores.
- Implement screenshot/clip exporter, social share hooks, landing page copy refresh, and localization pipeline.
- Optimize performance: offscreen canvas batching, frame-timed animations, asset preloading/compression.

## Tooling & Workflow Enhancements
- TypeScript for type safety on tiles, items, and UI bindings; generate docs with Typedoc.
- GitHub Actions pipeline that runs `npm ci`, `npm run build`, `npm test`, verifying `docs/` output is current.
- Visual regression and interaction tests via Playwright/Cypress simulating swaps and validating board state.
- Design tokens (colors, spacing, typography) shared between CSS and canvas rendering using CSS variables/data files.

## GitHub Pages Deployment
- `npm run build`:
  1. Compile `src/` to `docs/` (e.g., `tsc --outDir docs --module esnext` + optional `esbuild` minification).
  2. Copy static assets (`public/`) into `docs/`.
  3. Ensure `docs/index.html` references the bundled output with relative paths (e.g., `<script type="module" src="./game.bundle.js"></script>`).
- Optional `npm run watch` (`tsc -w`) for local iteration; open `docs/index.html` directly or serve via `python3 -m http.server` when needed.
- Configure GitHub Pages to publish from `docs/`; add README note reminding contributors to run `npm run build` before commits.

## Immediate Next Steps
- Scaffold `src/` structure, migrate existing logic into TypeScript modules, and set up the build scripts.
- Draft UX wireframes and art/audio mood boards aligned with the neon arcade theme.
- Plan playtest milestones: post-refactor stability check, special-tile prototype, level goals beta, live-ops soft launch.
